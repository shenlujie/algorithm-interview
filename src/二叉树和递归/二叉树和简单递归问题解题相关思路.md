## 1、二叉树的所有路径

 - 新建一个list
 - 递归边界：当遇到叶子节点时，list直接存入该节点的值并返回该list
 - 遍历所有左子树的字符串并拼接到头节点的下面
 - 遍历所有右子树的字符串并拼接到头节点的下面
 - 返回该list
## 2、二叉树的最大深度
 - 递归边界：root为null时，返回0
 - 递归逻辑：返回左右子树的最大深度的较大值+1

## 3、二叉树的最小深度

 - 递归边界：root为null时，返回0
 - 递归逻辑（分三种情况）：左子树为null右子树不为null、左子树不为null右子树为null、左右子树都不为null
 - 左子树为null右子树不为null：返回右子树的最小深度+1
 - 左子树不为null右子树为null：返回左子树的最小深度+1
 - 左右子树都不为null：返回左右子树的最小深度的较小值+1
## 4、二叉树的翻转
 - 递归边界：两种情况为（root为null或者root的左右子树都为null），不用翻转
 - 递归逻辑：将翻转后的左子树和翻转后的右子树交换位置
## 5、二叉树路径总和
 - 递归边界：root为叶子节点，直接返回root.val == sum
 - 递归逻辑：如果root左子树存在路径总和sum - root.val，返回true；如果root右子树存在路径总和sum - root.val，返回true；以上都不满足，返回false
## 6、二叉树的路径总和（起点终点不一定是root和叶子节点）
 - 递归分为两种情况：root包含在该路径上、root不包含在该路径上
 - root包含在该路径上，和第5条的逻辑一样
 - root不包含在该路径上，递归调用root.left和root.right，并将总和相加
## 7、二分搜索树的最小公共祖先
 - p、q两节点都在node的左子树，那么公共祖先就在node的左子树
 - p、q两节点都在node的右子树，那么公共祖先就在node的右子树
 - P、q两节点都不在同一侧，那么node就是最近公共祖先
## 递归的思路很简单：找到解决题目的最小递归架构（一颗最小的二叉树是天然的递归架构），然后分析这个结构中可能发生的所有情况，每种情况实现相应的逻辑即可
