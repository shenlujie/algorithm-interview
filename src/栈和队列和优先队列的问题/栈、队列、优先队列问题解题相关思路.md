## 1、stack
二叉树的前中后序遍历的非递归方式都可采用栈来解决。
设置一个Command类，存放treeNode、command（指令分为**visit和print**）：
将第一个节点作为Command类并**设置visit**存入stack，接着进行循环，每取出一个节点就分析其command，如果是visit就继续存放其左节点或右节点，如果是print就将其打印或者**添加到list**中。
## 2、queue
一、**二叉树的层序（广度优先）遍历**
如果遍历只是打印或者存入list中，非常方便，就和stack的简易版非递归中序遍历思路一样，只是把stack换成queue就行了。
如果是要按层将元素存成二维数组，就需要将queue中存放的treeNode改为Pair<TreeNode,<d>Integer>(一种非常简易的键值对，Integer表示层数)，思路不变。
二、**图的广度优先遍历**
利用图的广度优先遍历求一个**无权无向图**的最短路径：
设置一个起点**s**，设置一个**order**数组存放起点到各个节点的最短路径，设置一个**marked**数组存放该节点是否被访问过。将起点存入queue，每取出一个节点，就遍历该节点所有相邻的节点，接着将**还未访问过**的节点存入queue，并维护order和marked数组。

## 3、priorityQueue
求一个数组中出现频率最高的**前k个**元素。维护一个k大小的优先队列（最大堆）。
